## Make-a-bet challenge

_Author: Hck_  
_Tags: Crypto, PRNG_

### What I have to do

Game is about making bets. First you bet on result of coin tossing, second on number generated by PRNG. First one you have to win by luck. Second one by finding a way to predict/generate same numbers on your own computer.

### Identyfing PRNG

After connecting to the challenge and winning first round you'll be presented with a hint what you have to do. "Properly seeded old C rand() on old libc" and "number from 0-32767 range", let's break that down;

- **properly seeded** - propably(_pun intended_) you can't guess the seed from time, and it hasn't been set to 0.
- **old C rand()** - that means Linear Congruentia Pseudo Random Number Generator - check [Wikipedia](#) on that
- **range 0-32767** - 31bit limit, there is only one, that work on 31bits

So this will be LCPRNG with those parameters:

```
a = 1103515245
c = 12345
mask = 0x7fffffff
```

Sample(partial) source of generator(Ruby):

```ruby
def rand
    @state = (1103515245 * @state + 12345) & 0x7fffffff
    return @state>>16
end
```

### Exploiting PRNG

The thing that we need to predict next walues of PRNG is called *state* if we can find that out, we can put this state into our generator and check what numbers it will generate.

#### 1 Writing your own prng

You'll need that for testing and bruteforcing functionality. I believe that you can do it in your preffered language.

#### 1.5 Interpreting hint

|  i  |   bet  | result |
|:---:|:------:|-------:|
| 626 |  12458 |  23313 |
| 627 |  26964 |  11418 |
| 628 |   5096 |  26441 |
| 629 |  19702 |  24469 |
| 630 |  12841 |  25617 |

- `i` - gives us nothing
- `bet` - placed bet by other player, it's not connected any way with PRNG, so this gives us nothing too.
- `result` - that's an useful one. Sequence of 5 consecutive outputs of PRNG. We can assume that our number will be next. 

#### 2 Getting upper half - for free

That's an easy one. Upper half of the state is just the first result:

```
upper_part = results[0]
```

#### 3 Getting lower half - by bruteforce

Lower half gets mixed trough modulus and addition, but it's ony 16 bits, we can easy guess lower part of the PRNG.

Pseudocode (`|` means concaternate bits, like `0x11 | 0x22` makes `0x1122`)
```
upper part = results[0]
for each lower_part in 0 to 0xffff
    state_candidate = upper_part | lower part
    
    PRNG->set_state(state_candidate)
    next_number = PRNG->next()

    if( next_number equals results[1] )
        # We found it!
        found_state = state_candidate
        break loop!
    endif

    #check next
endfor

# got state(hopefuly)
```

### 4 Pimp up my code

Pseudocode from #3 not alway works correctly. I think thats one top bit we lose, you should add additional `if` and check against third number.

You have a code to find PRNGs state, use that to generate following numbers. Additional numbers given by service, should help you notice where you are with your PRNG.

### 5 Profit!

Congratz, if you coded everything correctly, you are now master of bets. Enjoy your flag.